<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<link href="exports.css" rel='stylesheet'>
<link href="exports.css" rel='stylesheet'>

</head>
<body>
<div id='wrap'>
<div id='header'>
<h1>Random tech links</h1>
<h2>
This is an archived post
</h2>
</div>
<div id='content'><div id='nav'>
<a href="oreilly-oscon-data-2011-steve-yegge-what-woul">Previous</a>
&nbsp; 
<a href="index-13">Index</a>
&nbsp; 
<a href="mjg59-further-adventures-in-efi-booting">Next</a>
</div>
<div class='post'>
<div class='post_header'>
<h3>LevelDB key-value library</h3>
<div class='post_info'>
<span class='post_time'>July 27 2011,  3:27 PM</span>
<span class='author'>&nbsp;by Alexey Shamrin</span>
</div>
</div>
<div class='post_body'><p><a href="http://code.google.com/p/leveldb/">LevelDB</a> is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.</p>

<p>Can be compared with SQLite and TokyoCabinet.</p>

<p>Great <a href="http://news.ycombinator.com/item?id=2526032">HN comments</a> (including the author):</p>

<p>About levels:</p>

<blockquote class="posterous_medium_quote"><p>To clarify, leveldb stores data in a sequence of levels. Each level stores
approximately ten times as much data as the level before it. A read needs
one disk seek per level. So if 10% of the db fits in memory, leveldb will
need to do one seek (for the last level since all of the earlier levels
should end up cached in the OS buffer cache). If 1% fits in memory, leveldb
will need two seeks.</p></blockquote>

<p>Google Chrome:</p>

<blockquote class="posterous_short_quote"><p>We&rsquo;re using leveldb as the back-end for IndexedDB in Chrome.</p></blockquote>

<p>Comparison with TokyoCabinet:</p>

<blockquote><p>One of the leveldb authors here. TokyoCabinet is something we
seriously considered using instead of writing leveldb. TokyoCabinet has great
performance usually. I haven&rsquo;t done a careful head-to-head comparison, but
it wouldn&rsquo;t surprise me if it was somewhat faster than leveldb for many
workloads. Plus TokyoCabinet is more mature, has matching server code
etc. and may therefore be a better fit for many projects.</p>

<p>However because of a fundamental difference in data structures (TokyoCabinet
uses btrees for ordered storage; leveldb uses log structured merge trees),
random write performance (which is important for our needs) is significantly
better in leveldb. This part we did measure. IIRC, we could fill TokyoCabinet
with a million 100-byte writes in less than two seconds if writing sequentially,
but the time ballooned to ~2000 seconds if we wrote randomly. The
corresponding slowdown for leveldb is from ~1.5 seconds (sequential) to
~2.5 seconds (random).</p></blockquote>

<p>There&rsquo;re wonderfully detailed and comprehensive <a href="http://leveldb.googlecode.com/svn/trunk/doc/benchmark">benchmarks against SQLite and TokyoCabinet</a> in the source. And <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl">implementation details</a>.</p></div>
<div class='post_tags'>
<h4>Tags</h4>
<div class='post_tags_list'>db</div>
</div>
<div class='post_responses'>
<h4>89 views and 0 responses</h4>
<ul class='post_responses list'>
</ul>
</div>
</div>
</div>
</div>
</body>
</html>
